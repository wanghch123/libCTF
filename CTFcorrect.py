#!/usr/bin/env python
# -*- coding:UTF-8 -*-
# AUTHOR: Minzhang Li & Haochen Wang
# FILE: ~/Projects/libCTF/CTF_calculate.py
# DATE: 2022/12/03 Sat
# TIME: 19:38:07

# DESCRIPTION: This code is for CTF calculation followed by CTF estimation (CTFfind). 
#              The implementation is based on CTFfind 1.10 version with minor revisement on artan term. (We will point it out detailly at followings)
#              To use this code, one needs `defocus_1`, `defocus_2` and `astigmatism_azimuth`. We provide a parsing functioin extracting them from 2 #              output files generated by CTFfind ( *.txt *_avrot.txt).

import numpy as np
import matplotlib.pyplot as plt
import mrcfile
import os
import argparse
from tqdm import tqdm
from multiprocessing import Pool
import time

class CTF_Estimator:
    def __init__(self, mrc_path, file_name, ctffind_out_path, pixel_size, amplitude_contrast = 0.07) -> None:
        self.lamb = self.calculate_wavelength(300) / pixel_size# 300V electron wavelength in A
        # print(self.lamb)
        # self.lamb = 0.00645273
        self.Cs =  2.7e7 / pixel_size  # spherical aberration in A
        self.amplitude_contrast = amplitude_contrast
        self.pixel_size = pixel_size

        self.mrc_path = mrc_path
        self.frames = mrcfile.open(mrc_path).data
        self.num_frames = self.frames.shape[0]
        self.fourier_frames = np.fft.fftshift(np.fft.fft2(self.frames), axes=(1,2))
        
        self.pi = 3.14159265359

        self.f1 = []
        self.f2 = []
        self.astigmatism_azimuth = []

        self.workspace_path = ctffind_out_path
        with open(os.path.join(ctffind_out_path, file_name + '.txt'), 'r') as f:
            lines = f.readlines()
            for i in range(5, len(lines)):
                line = lines[i].strip().split(' ')
                # print("micrograph: {} 's params is read".format(int(line[0])))
                self.f1.append(float(line[1])/self.pixel_size)
                self.f2.append(float(line[2])/self.pixel_size)
                self.astigmatism_azimuth.append(np.radians(np.float32(line[3])).astype(np.float32))

        self.f1 = np.array(self.f1, dtype='float32')
        self.f2 = np.array(self.f2, dtype='float32')
        self.astigmatism_azimuth = np.array(self.astigmatism_azimuth, dtype='float32')

        self.fre = []
        self.ctf_1d = []
        with open(os.path.join(ctffind_out_path, file_name + '_avrot.txt'), 'r') as f:
            lines = f.readlines()
            for i in range(5, len(lines), 6):
                self.fre.append(np.array(lines[i].strip().split(' '), dtype='float32'))
                self.ctf_1d.append(np.array(lines[i+3].strip().split(' '), dtype='float32'))
                
    def calculate_wavelength(self, voltage):
        return 12.26 / np.sqrt(1000 * voltage + 0.9784 * (1000 * voltage)**2 / (10**6))
    
    def calculate_defocus(self, alpha, idx):
        # return 0.5 * (1838.64 + 1833.86 + (1838.64 - 1833.86) * np.cos(2 * (alpha - self.astigmatism_azimuth[idx])))
        return 0.5 * (self.f1[idx] + self.f2[idx] + (self.f1[idx] - self.f2[idx]) * np.cos(2 * (alpha - self.astigmatism_azimuth[idx])))

    def calculate_defocuses(self, alpha):
        f1 = self.f1.reshape(-1,1,1)
        f2 = self.f2.reshape(-1,1,1)
        astigmatism_azimuth = self.astigmatism_azimuth.reshape(-1,1,1)
        defocuses = 0.5 * (f1 + f2 + (f1 - f2) * np.cos(2 * (alpha - astigmatism_azimuth)))
        return defocuses

    def calculate_astigmatism(self, defocus, g_square):
        return defocus - 0.5 * self.lamb**2 * g_square * self.Cs

    def calculate_phi(self, defocus, g_square):
        arch_term = np.arctan(self.amplitude_contrast / (np.sqrt(1 - self.amplitude_contrast**2, dtype='float32')))
        return self.pi * self.lamb * g_square * self.calculate_astigmatism(defocus, g_square) + arch_term

    def calculate_ctf(self, defocus, g_square):
        return -np.sin(self.calculate_phi(defocus, g_square))

    def cal_ctf(self):
        print("Calculating CTF...")
        nx, ny = self.frames[0].shape
        X = np.linspace(-nx//2, nx//2 - 1, nx) / nx
        Y = np.linspace(-ny//2, ny//2 - 1, ny) / ny
        X, Y = np.meshgrid(X, Y, indexing='ij')
        # print(nx, ny, X.shape, Y.shape)
        self.ctf = np.zeros(shape = (self.num_frames, nx, ny), dtype = 'float32')
        for idx in tqdm(range(self.num_frames)):
            for i in range(nx):
                for j in range(ny):
                    x = X[i,j]
                    y = Y[i,j]
                    alpha = np.arctan2(y, x)
                    defocus = self.calculate_defocus(alpha, idx)
                    g_square = (x**2 + y**2)
                    self.ctf[idx, i, j] = self.calculate_ctf(defocus, g_square)

    def cal_ctf_vectorized(self):
        nx, ny = self.frames[0].shape
        X = np.linspace(-nx//2, nx//2 - 1, nx) / nx
        Y = np.linspace(-ny//2, ny//2 - 1, ny) / ny
        X, Y = np.meshgrid(X, Y, indexing='ij')
        XY = np.concatenate([X[..., None], Y[..., None]], axis=-1).reshape(nx, ny, 2)
        alpha = np.arctan2(XY[..., 1], XY[..., 0])
        alpha = np.expand_dims(alpha, axis=0).repeat(self.num_frames, axis=0)
        g_square = np.sum(XY**2, axis=-1)
        g_square = np.expand_dims(g_square, axis=0).repeat(self.num_frames, axis=0)
        defouses = self.calculate_defocuses(alpha)
        # print(defouses.shape)
        phi = self.calculate_phi(defouses, g_square)
        # print(phi.shape)
        self.ctf = -np.sin(phi)
        print("Cs: ", self.Cs)
        print("lambda: ", self.lamb)
        # print(self.ctf.shape)
        # plt.imshow(np.abs(self.ctf[20]), cmap='gray')
        # plt.show()
    
    def cal_ctf_multi(self):
        resolution = self.frames[0].shape
        assert resolution[0] == resolution[1], 'image is not square'
        n = resolution[0]
        X = np.linspace(-1, 1, n)
        Y = np.linspace(-1, 1, n)
        N = np.arange(0, len(self.frames), 1)
        
        xx, yy, nn = np.meshgrid(X, Y, N)
        coord = np.concatenate([xx[..., None], yy[..., None], nn[..., None]], axis=-1).reshape(-1, 3)
        
        with Pool(8) as p:
            res = p.starmap(self.cal_ctf_pixel, coord) 
            p.close()
        return res
    
    def cal_ctf_pixel(self, x, y, idx):
        alpha = np.arctan2(y, x)
        defocus = self.calculate_defocus(alpha, idx)
        g_square = (x**2 + y**2) / (self.pixel_size * self.pixel_size)
        print("idx, x, y: ", idx, x, y)
        return np.abs(self.calculate_ctf(defocus, g_square))
        
    def compare_1DCTF(self, idx):
        defocus = self.calculate_defocus(self.astigmatism_azimuth[idx] + self.pi / 4, idx)
        ctf_1d = self.ctf_1d[idx]
        freq = self.fre[idx]

        f = np.zeros_like(freq)
        for i in range(len(freq)):
            g_square = freq[i] ** 2 * (self.pixel_size ** 2)
            f[i] = self.calculate_ctf(defocus, g_square)
        
        plt.subplot(121)
        plt.grid()
        plt.plot(freq, np.abs(f))
        plt.xlim(0, freq[-1])
        plt.xlabel("freq(1/Angstom)")
        plt.title("Our 1D CTF")

        plt.subplot(122)
        plt.grid()
        plt.plot(freq, ctf_1d)
        plt.xlim(0, freq[-1])
        plt.xlabel("freq(1/Angstrom)")
        plt.title("CTFfind 1D CTF")
        plt.show()

        print("Max error: ", np.max(np.abs(ctf_1d - np.abs(f))))
        print("Mean error: ", np.mean(np.abs(ctf_1d - np.abs(f))))    


    def do_ctf_correction(self, threshold = 0.2, flip = False):
        self.fourier_corrected_frames = np.zeros_like(self.frames)
        print("Doing CTF correction...")
        if flip:
            ctf_sign = np.sign(self.ctf)
            self.fourier_corrected_frames = self.fourier_frames * ctf_sign
        else:
            ctf_used = self.ctf
            ctf_used[np.abs(ctf_used) < threshold] = np.sign(ctf_used[np.abs(ctf_used) < threshold]) * threshold
            self.fourier_corrected_frames = np.divide(self.fourier_frames, ctf_used)

        self.corrected_frames = np.real(np.fft.ifft2(np.fft.ifftshift(self.fourier_corrected_frames, axes=(1,2)),axes=(1,2)))

    def output_mrc(self):
        output_mrc_path = os.path.join(self.workspace_path, "output")
        if not os.path.exists(output_mrc_path):
            os.mkdir(output_mrc_path)
        self.cal_ctf_vectorized()
        for t in tqdm([0.1, 0.2, 0.5]):
            self.do_ctf_correction(t)
            with mrcfile.new(os.path.join(output_mrc_path, "ctf_corrected_noabs_t_{}.mrc".format(t)), overwrite=True) as mrc:
                mrc.set_data(self.corrected_frames.astype('float32'))
                mrc.close()
        # self.do_ctf_correction(flip = True)
        # with mrcfile.new(os.path.join(output_mrc_path, "ctf_corrected_flip.mrc"), overwrite=True) as mrc:
        #     mrc.set_data(self.corrected_frames.astype('float32'))
        #     mrc.close()

    def plot_ctf_correction(self, idx):
        frame = self.frames[idx]
        fourier_frame = self.fourier_frames[idx]

        nx, ny = self.frames[0].shape
        X = np.linspace(-nx//2, nx//2 - 1, nx) / nx
        Y = np.linspace(-ny//2, ny//2 - 1, ny) / ny
        # print(X, Y)
        X, Y = np.meshgrid(X, Y, indexing='ij')

        local_ctf = np.zeros(shape = (nx, ny))
        for i in range(nx):
            for j in range(ny):
                x = X[i,j]
                y = Y[i,j]
                alpha = np.arctan2(y, x)
                defocus = self.calculate_defocus(alpha, idx)
                g_square = (x**2 + y**2)
                local_ctf[i, j] = np.abs(self.calculate_ctf(defocus, g_square))

        # plt.imshow(local_ctf, cmap='gray')
        # plt.title("CTF for frame {}".format(idx))
        # plt.colorbar()
        # plt.show()

        local_ctf[np.abs(local_ctf) < 0.2] = 0.2# * np.sign(local_ctf[np.abs(local_ctf) < 0.2])

        corrected_fourier_frame = np.divide(fourier_frame, local_ctf)
        temp = np.fft.ifft2(np.fft.ifftshift(corrected_fourier_frame, axes=(0,1)),axes=(0,1))
        # print(temp)
        corrected_frame = np.real(temp)

        # print(local_ctf[20,10], local_ctf[nx-20, ny-10])
        # print(fourier_frame[20,10], fourier_frame[nx-20, ny-10])
        # print(corrected_fourier_frame[80,50], corrected_fourier_frame[nx-80, ny-50])

        plt.subplot(221)
        plt.imshow(frame, cmap='gray')
        plt.title("Original image")

        plt.subplot(222)
        plt.imshow(corrected_frame, cmap='gray')
        plt.title("CTF corrected image")

        v_max = np.log(np.max([np.max(np.abs(fourier_frame)), np.max(np.abs(corrected_fourier_frame))]))
        v_min = np.log(np.min([np.min(np.abs(fourier_frame)), np.min(np.abs(corrected_fourier_frame))]))
        print(v_max, v_min)
        plt.subplot(223)
        plt.imshow(np.log(np.abs(fourier_frame)), cmap='gray', vmin=v_min, vmax=v_max+1)
        plt.title("Fourier transform of original image")

        plt.subplot(224)
        plt.imshow(np.log(np.abs(corrected_fourier_frame)), cmap='gray', vmin=v_min, vmax=v_max+1)
        plt.title("Fourier transform of CTF corrected image")

        plt.show()

if __name__ == '__main__':
    parser = argparse.ArgumentParser(" CTF correct ")
    parser.add_argument("-i", "--input_mrc", type=str, default="./assets/20210929_21_ali.mrc", )
    parser.add_argument("--workspace", type=str, default= "./workspace/21", )
    parser.add_argument("--filename", type=str, default='diagnostic_output')
    parser.add_argument("-p", "--pixel_size", type=float, default=3.05)
    args = parser.parse_args()
    my_ctf = CTF_Estimator(args.input_mrc, args.filename, args.workspace, args.pixel_size)
    # my_ctf.compare_1DCTF(20)
    # my_ctf.cal_ctf()
    # my_ctf.show_ctf(20)
    # print(len(my_ctf.cal_ctf_multi()),)
    # my_ctf.cal_ctf()
    # my_ctf.do_ctf_correction()
    # my_ctf.plot_ctf_correction(20)
    # my_ctf.cal_ctf_vectorized()
    my_ctf.output_mrc()